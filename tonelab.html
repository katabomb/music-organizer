<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ãƒ–ãƒ©ã‚¦ã‚¶ä½œæ›²ã‚¹ã‚¿ã‚¸ã‚ªï¼ˆWAVå‡ºåŠ›ã¤ãï¼‰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 10px;
      line-height: 1.4;
    }
    h1 {
      font-size: 1.2rem;
      margin-bottom: 0.5rem;
    }
    .panel {
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 8px;
      margin-bottom: 10px;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    label {
      font-size: 0.9rem;
    }
    input, select {
      font-size: 1rem;
    }
    button {
      font-size: 1rem;
      padding: 8px 12px;
      border-radius: 6px;
      border: 1px solid #888;
      background: #f0f0f0;
      cursor: pointer;
      touch-action: manipulation;
    }
    button:active {
      background: #ddd;
    }
    #keyboard button {
      min-width: 48px;
      padding: 10px 4px;
    }
    #trackDisplay {
      font-size: 0.85rem;
      white-space: pre-wrap;
      background: #fafafa;
      border-radius: 6px;
      padding: 6px;
      max-height: 150px;
      overflow-y: auto;
    }
    .track-title {
      font-weight: bold;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <h1>ãƒ–ãƒ©ã‚¦ã‚¶ä½œæ›²ã‚¹ã‚¿ã‚¸ã‚ªï¼ˆ3ãƒˆãƒ©ãƒƒã‚¯ãƒ»éŸ³è‰²å¤‰æ›´ãƒ»WAVå‡ºåŠ›ï¼‰</h1>

  <!-- ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ« -->
  <div class="panel">
    <div class="row" style="margin-bottom:6px;">
      <label>ãƒˆãƒ©ãƒƒã‚¯:
        <select id="trackSelect">
          <option value="0">ãƒˆãƒ©ãƒƒã‚¯1</option>
          <option value="1">ãƒˆãƒ©ãƒƒã‚¯2</option>
          <option value="2">ãƒˆãƒ©ãƒƒã‚¯3</option>
        </select>
      </label>
      <label>éŸ³è‰²:
        <select id="waveformSelect">
          <option value="sine">sineï¼ˆã‚„ã‚ã‚‰ã‹ã„ï¼‰</option>
          <option value="square">squareï¼ˆãƒ”ã‚³ãƒ”ã‚³ï¼‰</option>
          <option value="sawtooth">sawtoothï¼ˆãƒ–ãƒ¼ãƒ³ï¼‰</option>
          <option value="triangle">triangleï¼ˆã‚„ã‚„ç¡¬ã‚ï¼‰</option>
        </select>
      </label>
      <label>BPM:
        <input type="number" id="bpmInput" value="100" min="40" max="200" style="width:70px;">
      </label>
      <label>éŸ³ã®é•·ã•:
        <select id="durationSelect">
          <option value="1">1æ‹ï¼ˆ4åˆ†éŸ³ç¬¦ï¼‰</option>
          <option value="2">2æ‹ï¼ˆ2åˆ†éŸ³ç¬¦ï¼‰</option>
          <option value="0.5">0.5æ‹ï¼ˆ8åˆ†éŸ³ç¬¦ï¼‰</option>
        </select>
      </label>
    </div>
    <div class="row">
      <button type="button" id="playBtn">â–¶ å†ç”Ÿ</button>
      <button type="button" id="saveBtn">ğŸ’¾ WAVã§ä¿å­˜</button>
      <button type="button" id="undoBtn">â†© ã²ã¨ã¤æˆ»ã™</button>
      <button type="button" id="clearTrackBtn">ğŸ§¹ ã“ã®ãƒˆãƒ©ãƒƒã‚¯ã‚’ã‚¯ãƒªã‚¢</button>
      <button type="button" id="clearAllBtn">ğŸ”¥ å…¨ãƒˆãƒ©ãƒƒã‚¯ã‚’ã‚¯ãƒªã‚¢</button>
      <button type="button" id="addRestBtn">â¸ ä¼‘ç¬¦ã‚’è¿½åŠ </button>
    </div>
  </div>

  <!-- éµç›¤ -->
  <div class="panel">
    <div>éµç›¤ï¼ˆã‚¿ãƒƒãƒ—ã§ãƒãƒ¼ãƒˆã‚’è¿½åŠ ï¼‰ï¼š</div>
    <div id="keyboard" class="row" style="margin-top:6px;"></div>
  </div>

  <!-- ãƒˆãƒ©ãƒƒã‚¯ã®ä¸­èº«è¡¨ç¤º -->
  <div class="panel">
    <div>ç¾åœ¨ã®æ¥½è­œï¼š</div>
    <div id="trackDisplay"></div>
  </div>

  <script>
    // ====== éŸ³éšå®šç¾©ï¼ˆC4ã€œC5ï¼‰ ======
    const NOTES = [
      { name: "C4", freq: 261.63 },
      { name: "D4", freq: 293.66 },
      { name: "E4", freq: 329.63 },
      { name: "F4", freq: 349.23 },
      { name: "G4", freq: 392.00 },
      { name: "A4", freq: 440.00 },
      { name: "B4", freq: 493.88 },
      { name: "C5", freq: 523.25 }
    ];

    // ====== ãƒˆãƒ©ãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ ======
    // å„ãƒˆãƒ©ãƒƒã‚¯ã¯ {freq, beats, label} ã®é…åˆ—
    const tracks = [[], [], []];

    // ====== UIè¦ç´  ======
    const trackSelect = document.getElementById("trackSelect");
    const waveformSelect = document.getElementById("waveformSelect");
    const bpmInput = document.getElementById("bpmInput");
    const durationSelect = document.getElementById("durationSelect");
    const trackDisplay = document.getElementById("trackDisplay");

    let bpm = 100; // åˆæœŸå€¤
    function secondsPerBeat() {
      return 60 / bpm;
    }

    // ====== iPadç”¨ AudioContextï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å†ç”Ÿï¼‰ ======
    let audioCtx = null;
    function getAudioCtx() {
      if (!audioCtx) {
        const AC = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AC();
      }
      return audioCtx;
    }

    // ====== éµç›¤ã‚’ç”Ÿæˆ ======
    const keyboardDiv = document.getElementById("keyboard");
    NOTES.forEach(note => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.textContent = note.name;
      btn.addEventListener("click", () => {
        addNoteToCurrentTrack(note.freq, note.name);
      });
      keyboardDiv.appendChild(btn);
    });

    // ====== ãƒˆãƒ©ãƒƒã‚¯ã«ãƒãƒ¼ãƒˆè¿½åŠ  ======
    function addNoteToCurrentTrack(freq, label) {
      const trackIndex = parseInt(trackSelect.value, 10);
      const beats = parseFloat(durationSelect.value);
      tracks[trackIndex].push({ freq, beats, label });
      updateTrackDisplay();
    }

    // ====== ä¼‘ç¬¦è¿½åŠ  ======
    document.getElementById("addRestBtn").addEventListener("click", () => {
      const trackIndex = parseInt(trackSelect.value, 10);
      const beats = parseFloat(durationSelect.value);
      tracks[trackIndex].push({ freq: null, beats, label: "ä¼‘ç¬¦" });
      updateTrackDisplay();
    });

    // ====== ãƒˆãƒ©ãƒƒã‚¯è¡¨ç¤ºæ›´æ–° ======
    function updateTrackDisplay() {
      let text = "";
      tracks.forEach((track, idx) => {
        text += `ãƒˆãƒ©ãƒƒã‚¯${idx + 1}:\n`;
        if (track.length === 0) {
          text += "  ï¼ˆãªã—ï¼‰\n\n";
        } else {
          text += "  " + track.map(n => n.label).join(" | ") + "\n\n";
        }
      });
      trackDisplay.textContent = text;
    }

    // ====== BPMå¤‰æ›´ ======
    bpmInput.addEventListener("change", () => {
      const v = parseInt(bpmInput.value, 10);
      if (!isNaN(v) && v > 20 && v < 300) {
        bpm = v;
      } else {
        bpm = 100;
        bpmInput.value = 100;
      }
    });

    // ====== ã²ã¨ã¤æˆ»ã™ ======
    document.getElementById("undoBtn").addEventListener("click", () => {
      const trackIndex = parseInt(trackSelect.value, 10);
      tracks[trackIndex].pop();
      updateTrackDisplay();
    });

    // ====== ã“ã®ãƒˆãƒ©ãƒƒã‚¯ã‚’ã‚¯ãƒªã‚¢ ======
    document.getElementById("clearTrackBtn").addEventListener("click", () => {
      const trackIndex = parseInt(trackSelect.value, 10);
      tracks[trackIndex] = [];
      updateTrackDisplay();
    });

    // ====== å…¨ãƒˆãƒ©ãƒƒã‚¯ã‚’ã‚¯ãƒªã‚¢ ======
    document.getElementById("clearAllBtn").addEventListener("click", () => {
      for (let i = 0; i < tracks.length; i++) {
        tracks[i] = [];
      }
      updateTrackDisplay();
    });

    // ====== ãƒˆãƒ©ãƒƒã‚¯ã®ç·æ‹æ•° ======
    function trackBeats(track) {
      return track.reduce((sum, n) => sum + n.beats, 0);
    }

    // ====== ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å†ç”Ÿ ======
    document.getElementById("playBtn").addEventListener("click", async () => {
      const ctx = getAudioCtx();
      if (ctx.state === "suspended") {
        try { await ctx.resume(); } catch (e) { console.error(e); }
      }

      const wave = waveformSelect.value;
      const spb = secondsPerBeat();

      tracks.forEach(track => {
        let t = ctx.currentTime + 0.05; // ä¸€ç¬å…ˆã‹ã‚‰
        track.forEach(n => {
          const dur = n.beats * spb;
          if (n.freq) {
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = wave;
            osc.frequency.value = n.freq;
            gain.gain.setValueAtTime(0.2, t);
            gain.gain.linearRampToValueAtTime(0.0, t + dur);
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start(t);
            osc.stop(t + dur);
          }
          t += dur;
        });
      });
    });

    // ====== WAVä¿å­˜ ======
    document.getElementById("saveBtn").addEventListener("click", async () => {
      const wave = waveformSelect.value;
      const spb = secondsPerBeat();
      const sampleRate = 44100;

      // å…¨ãƒˆãƒ©ãƒƒã‚¯ã®ä¸­ã§ä¸€ç•ªé•·ã„æ‹æ•°ã‚’æ±‚ã‚ã‚‹
      const maxBeats = tracks.reduce((m, tr) => Math.max(m, trackBeats(tr)), 0);
      if (maxBeats === 0) {
        alert("æ¥½è­œãŒç©ºã§ã™ã€‚å…ˆã«ãƒãƒ¼ãƒˆã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚");
        return;
      }
      const totalDuration = maxBeats * spb + 0.1;

      const offlineCtx = new OfflineAudioContext(1, sampleRate * totalDuration, sampleRate);

      tracks.forEach(track => {
        let t = 0;
        track.forEach(n => {
          const dur = n.beats * spb;
          if (n.freq) {
            const osc = offlineCtx.createOscillator();
            const gain = offlineCtx.createGain();
            osc.type = wave;
            osc.frequency.value = n.freq;
            gain.gain.setValueAtTime(0.2, t);
            gain.gain.linearRampToValueAtTime(0.0, t + dur);
            osc.connect(gain);
            gain.connect(offlineCtx.destination);
            osc.start(t);
            osc.stop(t + dur);
          }
          t += dur;
        });
      });

      const buffer = await offlineCtx.startRendering();
      const wavData = audioBufferToWav(buffer);
      const blob = new Blob([wavData], { type: "audio/wav" });

      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "composition.wav";
      a.click();
      URL.revokeObjectURL(url);
    });

    // ====== AudioBuffer â†’ WAV å¤‰æ› ======
    function audioBufferToWav(buffer) {
      const numOfChannels = buffer.numberOfChannels;
      const length = buffer.length * numOfChannels * 2 + 44;
      const result = new ArrayBuffer(length);
      const view = new DataView(result);

      function writeString(v, offset, s) {
        for (let i = 0; i < s.length; i++) {
          v.setUint8(offset + i, s.charCodeAt(i));
        }
      }

      let offset = 0;

      // RIFFãƒ˜ãƒƒãƒ€
      writeString(view, offset, "RIFF"); offset += 4;
      view.setUint32(offset, 36 + buffer.length * numOfChannels * 2, true); offset += 4;
      writeString(view, offset, "WAVE"); offset += 4;

      // fmtãƒãƒ£ãƒ³ã‚¯
      writeString(view, offset, "fmt "); offset += 4;
      view.setUint32(offset, 16, true); offset += 4;
      view.setUint16(offset, 1, true); offset += 2; // PCM
      view.setUint16(offset, numOfChannels, true); offset += 2;
      view.setUint32(offset, buffer.sampleRate, true); offset += 4;
      view.setUint32(offset, buffer.sampleRate * numOfChannels * 2, true); offset += 4;
      view.setUint16(offset, numOfChannels * 2, true); offset += 2;
      view.setUint16(offset, 16, true); offset += 2; // 16bit

      // dataãƒãƒ£ãƒ³ã‚¯
      writeString(view, offset, "data"); offset += 4;
      view.setUint32(offset, buffer.length * numOfChannels * 2, true); offset += 4;

      // PCMæœ¬ä½“
      let pos = offset;
      for (let ch = 0; ch < numOfChannels; ch++) {
        const data = buffer.getChannelData(ch);
        for (let i = 0; i < data.length; i++, pos += 2) {
          const s = Math.max(-1, Math.min(1, data[i]));
          view.setInt16(pos, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
        }
      }
      return result;
    }

    // åˆæœŸè¡¨ç¤ºæ›´æ–°
    updateTrackDisplay();
  </script>
</body>
</html>
